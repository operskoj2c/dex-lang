'# Dex Tutorial

' Dex is a functional, statically typed language for array processing. There are
  many tools for array processing, from high-level libraries like NumPy and
  MATLAB to low-level languages like CUDA. Dex gives you many of the safety and
  simplicity benefits of high-level array processing languages, without
  requiring that users give up low-level control.


include "plot.dx"


'## Table comprehensions

' Before getting into language details, let us begin with the most useful
  component of Dex, the `for` builder. The best analogy for this construct is
  list comprehensions in Python. For instance, in Python, we might write a
  list comprehension like:

' `x = [[1.0 for j in range(width)] for i in range(height)]`

' In Dex, this construct would be written as:

Height = Fin 3
Width = Fin 8

x = for i:Height. for j:Width. 1.0

' Once we have an variable, we can print it `:p`

:p x

' More interestingly, we can also see its type with `:t`. This type tells us
  that `x` is a two-dimensional table, whose first dimension has size `Height` and
  second dimension has size `Width`.

:t x

' We can also display it as html. Right now not so interesting :)

:html matshow x

' Once we have an table, we can use it in new comprehensions. For example,
  let's try to add `5` to each table element. In Python, one might write this as:

' `x5 = [[x[i][j] + 5.0 for j in range(width)] for i in range(height)]`

' Dex can do something similar. The main superficial difference is the
  table indexing syntax, which uses `table.i` instead of square brackets for
  subscripting.

x5 = for i:Height. for j:Width. x.i.j + 5.0

:p x5

' However, we can make this expression nicer. Because `x` has a known table type
  and `i` and `j` index into that type, Dex can infer the range of the loop.
  That means that we can safely remove the explicit `Fin` type annotations and
  get the same result.

x5' = for i. for j. x.i.j + 5.0

' We can further reduce this table by applying standard table reduction functions like
  `mean` over each column:

:t for i. mean x.i

' This style of using `for` to construct type-inferred tables is central to what
  makes Dex powerful.

' Let's consider another example. This one produces a list of
  length 50 in Python.

' `y = [1.0 for j in range(width) for i in range(height)]`

' The analogous table construct in Dex is written in the following form. It
  produces a one-dimensional table of `Height x Width` elements.

y = for  (i, j) : (Height & Width) . 1.0

' As before, we can implement "adding 5" to this table using a `for` constructor,
  enumerating over each of its elements:

y5 = for i. y.i + 5.0

' And we can apply table functions to the table:

:t mean y

' But things start to get interesting when we consider the type of the table.
  Unlike the Python example, which produces a flat list, the Dex table
  maintains the index type of its construction. In particular, the type of the
  table remembers the original ranges.

:t y

'## Typed indexing

' The use of typed indices lets you do really neat things, but it
  breaks things from other languages. Critically, one cannot
  simply index an table with an integer.

r = x.3

' Instead, it is necessary to cast the integer into the index type of the
  current shape. This type annotation is done with the `@` operator. (If it
  helps, you can think of table indexing as function application: `a.i` applies
  table `a` with index `i` just like how `f x` applies function `f` with
  argument `x`.)

:t x

row = x.(3 @ Height)

:t row

:t row.(5 @ Width)

' This explicit annotation is a bit verbose, but it is often not necessary in
  practice. Constructs like `for` can infer index types,
  which is why we didn't have to use any `@` symbols when constructing above.

' Similarly, you cannot use indices as integers as you might be used to. It is
  necessary to explicitly annotate index types.

:t for i:Height. for j:Width. i + j

:t for i:Height. for j:Width. (ordinal i) + (ordinal j)

' If we want to convert these to floats we do it manually with the IToF function.
  We can use to this to make a pretty gradient.

gradient = for i:Height. for j:Width. IToF ((ordinal i) + (ordinal j))
:html matshow gradient

' As we have seen, indices are not limited to only integers. Many different Dex
  types are valid index types. For example, we declared table `x2` as having a
  pair of integers as its index type (`a & b` means tuple type), so indexing
  into `x2` requires creating a tuple value (via `(x, y)`).

:t y

:t y.(3 @ Height, 5 @ Width)

' Many algorithms in Dex come down to being able to pack and unpack these
  indices. For example, we have seen that it is easy to sum over one dimension
  of a 2D table.  However, if we have a 1D table indexed by a pair, we can
  easily turn it into a 2D table using two `for` constructors.

:t for i. for j. y.(i, j)

' Again, we rely on type inference in order to avoid explicitly spelling the
  ranges.


' ## Defining functions over tables

' One use case of packing and unpacking table indices is that it allows us to
  change the order of the axes. This is useful for applying functions on tables.

' For instance, we saw the `mean` function above which sums over the first axis
  of an table. We can apply `mean` to `x2` to produce the sum over 50 elements:

:t y

:t mean y


' The `mean` function works independently of the index type of the table.

' Let's see how we can define our own table functions. Defining a function in
  Dex uses the following syntax. 

def add5 (x:Float32) : Float32 =
    x + 5.0

:p add5 1.0

:t for i. add5 y.i

' We can also write functions with type variables over their inputs. For
  instance, we may want to be able to write a function that applies "adds 5"
  to tables with _any_ index type. This is possible by declaring an `n => Int32`
  table argument type: this declares the type variable `n` as the index type of
  the table argument.

def tabAdd5 (x : n => Float32) : n => Float32 =
    for i. x.i + 5.0

:t tabAdd5 y

' But function types can help you out even more. For instance, since index types
  are statically known, type checking can ensure that table arguments have valid
  dimensions. This is "shape safety".

' Imagine we have `transpose` function. We can encode the shape change in the type. 

def transFloat (x : m => n => Float32) : n => m => Float32 =
    for i. for j. x.j.i

' We can even make it more generic by abstracting over the value type. 

def trans (x : m => n => v) : n => m => v =
    for i. for j. x.j.i


' We can also use this to check for shape errors:

:t x

def tabAdd (x : m => n => Float32) (y : m => n => Float32) : m => n => Float32 =
    for i. for j. x.i.j + y.i.j

:t tabAdd x x

:t tabAdd x (trans x)

' The type system checked for us that input tables indeed have the same shape.


'## Case Study: MNist

' To make some of these concepts for tangible let us consider a real example
  using MNist digits. For this example we will first read in a batch of images
  each with a fixed size.

Batch = Fin 10
IHeight = Fin 28
IWidth = Fin 28
Channels = Fin 3 
Full = Fin ((size Batch) * (size IHeight) * (size IWidth))

' To do this we will use Dex's IO to load some images from a file.
  This part uses some features we have not yet covered, so you can
  ignore it for now. 

raw =
    ls = unsafeIO $ \ _. readFile (AsList _ ['e', 'x', 'a', 'm', 'p', 'l', 'e', 's', '/', 'c', 'm', 'n'])
    (AsList _ im) = ls
    unsafeCastTable Full im

def pixel (x:Char) : Float32 =
     r = W8ToI x
     IToF case r < 0 of
             True -> (abs r) + 128
             False -> r

' Here we use comprehensions to create the full data table.


ims =
   for b: Batch.
     for i:IWidth.
       for j:IHeight.
          pixel raw.((ordinal (b, i, j)) @ Full)

' We can look at the images we have loaded now using `matshow` 

:html matshow ims.(0 @ Batch)

:html matshow ims.(1 @ Batch)

' We might also use aggregation to compute image statistics.

:html matshow (sum ims)

' This example overplots three different handwritten images.

imscolor = for i. for j. for c:Channels. ims.((ordinal c)@Batch).i.j

:t imscolor

:html imshow (imscolor / 255.0)

' This one shows all the images on one channel over the base plot.

imscolor2 = for b. for i. for j. for c:Channels.
          case ordinal c == 0 of 
             True -> (sum ims).i.j / (IToF (size Batch))
             False -> ims.b.i.j 

:html imseqshow (imscolor2 / 255.0)

' Sum pooling downsamples the image as the max of each pixel in a tile grid pattern. 

def split (x: m=>v) : n=>o=>v =
    for i. for j. x.((ordinal (i,j))@m)
            
def imtile (x: a=>b=>v) : n =>o=>p=>q=>v =
    for kw. for kh. for w. for h. (split (split x).w.kw).h.kh

im1 : Fin 2 => Fin 2 => Fin 14 => Fin 14 => Float32 = imtile ims.(0@Batch)

:html matshow (sum (sum im1))

im2 : Fin 4 => Fin 4 => Fin 7 => Fin 7 => Float32 = imtile ims.(0@Batch)

:html matshow (sum (sum im2))


'## Writing Loops

' Dex is a functional language - but when writing mathematical algorithms,
  it is often convenient to temporarily put aside immutability and write
  imperative code using mutation.

' For example, let's say we want to actually implement the `mean` function
  ourselves by accumulating summed values in-place. In Python, implementing this
  is not directly possible solely via list comprehensions, so we would write a
  loop.

'  `acc = 0`

'  `for i in range(len(x)):`

'      `acc = acc + x[i]`

'  `return acc / len(x)

' In Dex, values are immutable, so we cannot directly perform mutation. But Dex
  includes algebraic effects, which are a purely-functional way to modeling
  side-effects like mutation. We can write code that looks like mutation using
  the `State` effect, which provides getter and setter functionality (via `get`
  and `:=` assignment). Here's what it looks like:

def tabMean (x : n => Float32) : Float32 =
    -- acc = 0
    init = 0.0

    -- (New Line)
    withState init $ \acc.
    
         -- for i in range(len(x))
         for i.
             -- acc = acc + x[i]
             acc := (get acc) + x.i
             
         -- return acc / len(x)
         (get acc) / (IToF (size n)) 
             
:p tabMean [0.0, 1.0, 0.5]

' So, even though Dex is a functional language, it is possible to write loops
  that look similar to ones that truly perform mutation. However, there is one
  line which is quite new and a bit scary. Let us look into that line in a bit
  more detail.

' First: `$`. This symbol is used in Dex just like it is used in Haskell, but
  if you haven't seen it before, it seems a bit strange. The symbol `$` is the function
  application operator: it basically replaces of expression-grouping parentheses
  `(f x)` when it is inconvenient to write them. For example, the following two
  expressions are identical:

:t tabMean (y + y)

:t tabMean $ y + y

' Next: `\`. This symbol is the lambda sigil in Dex. It is analogous to the
  `lambda` keyword in Python, and starts the definition of a function value
  (i.e. closure). In `tabMean` above: the lambda takes an argument named `acc`
  and returns the body, which is the expression following the `.` (a `for`
  constructor in this case).

:t \ x. x + 10

:p (\ x. x + 10) 20  

' That leaves: `withState`. This function uses the `State` effect, enabling us
  to introduce imperative variables into the computation.
  `withState` takes an initial value `init` and a body function taking a
  "mutable value" reference (`acc` here), and returns a pair of the body
  function's result and the final value. Here's a simple example:

:p withState 10 $ \ state.
     state := 30
     state := 10
     get state

' The first element of the returned pair is the body function's result (`20`).
  The second element is the final value of the variable (`30`).

' Finally: this is a good point to talk a bit about some other operators in Dex.
  In the examples above, we see two types of equal sign operators: `=` and `:=`.
  The first is the `let` operator that creates an immutable assignment (a
  "let-binding"). This one is built into the language and can be used anywhere.

:t for i:Height.
        -- Bind a temporary variable `temp`, as an example.
        temp = (ordinal i) + 10
        for j:Width.
            temp

' The other is `:=`, which is an assignment operator that can only be used
  when a `State` effect is available (e.g. inside of a body function passed to
  `withState`. `ref := x` assigns the value `x` to the mutable reference `ref`.
  Reading the value in `ref` is possible via the `get` function. or via using
  the final result returned by `withState`.

'## Typeclasses

' Our `tabMean` function is pretty neat. It lets us work with tables with any
  index type and computes the sum. However, `tabMean` explicitly takes only
  integer tables (of type `n => Float32`).

:t tabMean

' If we try to apply `tabMean` to other types for get errors. For example, what if
  we have a table of pairs of floats, the function does not work.

:t (for (i, j). (x.i.j, x.i.j))

tabMean (for (i, j). (x.i.j, x.i.j))

' Intuitively this seems like it could work. We just need to be able to
  add and divide pairs. Let's look a bit close at the types of add and
  divide.


:t (+)

:t (/)


' These types are a bit complex. Add maps `a -> a -> a` with a constraint that
  `a` be in the type class `Add`. Whereas divide maps `a -> Float32 -> a`
   where `a` is in the type class `VSpace`.

' If we look in the prelude we can see that these type class interfaces are
  defined as: 

interface Add a
  add : a -> a -> a
  sub : a -> a -> a
  zero : a


interface [Add a] VSpace a
  scaleVec : Float -> a -> a

' They tell us which functions we need to define for a type to work with them. 
  It it relatively straightforward to add a new instance. 

' Here is an interface for adding float pairs.

instance Add (Float32 & Float32)
  add = \(x1,x2) (y1, y2). (x1 + y1, x2 + y2)
  sub = \(x1,x2) (y1, y2). (x1 - y1, x2 - y2)
  zero = (0.0, 0.0)

' And dividing a float pair by a constant.

instance VSpace (Float32 & Float32)
  scaleVec = \s (x, y). (x / s, y / s)

' Once we have these two instance definitions (`MyAdd Int32` and
  `MyAdd Float32`), we can revisit our table sum function and add a typeclass
  constraint:

def tabMean2 [VSpace v] (x : n => v) : v =
    withState zero $ \acc.
        for i.
            acc := (get acc) + x.i
        (get acc) / (IToF (size n))   

tabMean2 [0.1, 0.5, 1.0]

tabMean2 [(1.0, 0.5), (0.5, 0.8)]


' To be more general, we could have also defined these instance for all tuple
  types.


instance [Add v, Add w] Add (v & w)
  add = \(x1,x2) (y1, y2). (x1 + y1, x2 + y2)
  sub = \(x1,x2) (y1, y2). (x1 - y1, x2 - y2)
  zero = (zero, zero)

instance [VSpace v, VSpace w] VSpace (v & w)
  scaleVec = \s (x, y). (x / s, y / s)


'## Worked examples: Project Euler

' To demonstrate Dex in practice, below are some examples of solving problems
  from [Project Euler](https://projecteuler.net).

def ignore (y:a) (x : Maybe a) : a =
  case x of
    Just x -> x
    Nothing -> y

instance [Add v] Add (Maybe v)
  add = \x y. Just $ ignore zero x + ignore zero y
  sub = \x y. Just $ ignore zero x - ignore zero y
  zero = Just zero

' ### Problem 1: Find the sum of all the multiples of 3 or 5 below 1000.

prob1 = for i : (Fin 1000).
          i' = ordinal i
          case ((i' `mod` 3) == 0 || (i' `mod` 5) == 0) of
            True ->  Just i'
            False -> Nothing

:p fromJust $ sum  prob1

' ### Problem 2: By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.



' TODO: Finish this part with some more examples