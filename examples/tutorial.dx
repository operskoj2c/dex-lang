'# Dex Tutorial


'Dex is a functional, statically typed language for array processing.
There are many tools for array processing from high-level libraries
like NumPy / MATLAB to low-level languages like CUDA. Dex gives you
many benefit of the safety and simplicity benefits of high-level array
processing languages, without requiring that you give up low-level
control.

'## Array Comprehensions


' Before getting into the details of the language, let us begin with
the most useful component of dex, the `for` builder. The best analogy
for this construct is list comprehensions in Python. For instance, in
Python we might write a list comprehension like:

' `x = [[1 for j in range(10)] for i in range(5)]`

' In Dex, this construct would be written as, 

x = for i:(Fin 5). for j:(Fin 10). 1


' Once we have an variable we can print it `:p` 

:p x

' More interestingly, we can also see its type with `:t`. This type
signature tells us that `x` is a two-dimensional array, with first
dimension of size 5 and the second of size 10.

:t x

' Once we have an array we can use it in new comprehensions. For example,
  if say we want to add `5` to each element of the array. In Python,
  you might write this as, 

' `y = [[x[i][j] for j in range(10)] for i in range(5)]`

' Dex can do something similar. The main superficial difference is the
  indexing syntax which uses `.` instead of brackets.

y = for i:(Fin 5). for j:(Fin 10). x.i.j + 5 

:p y

' However, we can make this expression nicer. Because `x` has a known type
  and `i` and `j` index into that type, Dex can infer the range of the loop.
  That means that we can safely remove `Fin` statements and get the same result.

y' = for i. for j. x.i.j + 5 


' We can further reduce this array by applying array functions such as `sum`. 

z = for i. sum x.i  

' This style of using the `for` construct to infer the loop range is
  central to what makes Dex powerful. Let's consider another example.
  This one produces a list of length 50 in Python.
  
' `x = [1 for j in range(10) for i in range(5)]`

' The analogous array construct in Dex is written in
  the following form. This produces a one dimension
  array of 50 elements. 

x2 = for (i, j): (Fin 5 & Fin 10). 1 


' As before, we can modify this array through another `for` constructor,
  which enumerates over each element of `x2`. Or by applying a function. 
  

y2 = for i. x2.i + 5 

:p sum x2

' But things start to get interesting when we consider the type of this array.
  Unlike the Python example that produces a list of length 50. The 
  Dex array maintains the index type of its construction. In particular
  the type of `x2` remembers the original ranges. 

:t x2


'## Typed Indexing  

' The use of typed indices lets you do some really neat things, but it
  also breaks some things in counterintuitive ways. Dex use the `.`
  syntax for indexing. Critically though, cannot simply index with a
  raw integer.

r = x.3

' Instead you need to cast your integer into the index type of the current
  shape. This is done with the `@` operator. (If it helps, you can think of `a.i`
  as passing index `i` to array `a` the same way `f x` passes arg `x` to function
  `f`.)

:t x

row = x.(3 @ Fin 5)

:t row

:t row.(5 @ Fin 10)

' This is bit verbose, but you rarely need to do it in practice. Most of the
  time, you index with the `for` construct which is able to infer the right indices.
  That's why we didn't have to use any `@` symbols when constructing `y2` above.

' Similarly you can't use indices as integers as you might be used to. You need to
  cast them out explicitly.


x4 = for i:(Fin 5). for j:(Fin 10). i + j


x4 = for i:(Fin 5). for j:(Fin 10). (ordinal i) + (ordinal j) 

  
' As we have seen though, indices do not need to just be integers. We can index with
  many different Dex type. For instance `x2` was indexed with a pair of integers (`&` means tuple)
  so we need to build a tuple in order to index.

:t x2

:t x2.(3@Fin 5, 5@Fin 10)

' A lot of algorithms in Dex come down to being able to pack and
  unpack these indices.  For example, we have seen that it is easy to
  sum over one dimension of a 2D array.  However, if we have a 1D
  array indexed by a pair, we can easily turn it into a 2D array by
  constructing it.

x3 = for i. for j. x2.(i, j)

:t x3

' Again we rely on type inference in order to avoid explicitly giving
the ranges.

' ## Functions over Arrays

' One use case of packing and unpacking array indices is that
  it allows us to change the order of the axes. This is useful for
  applying functions on arrays.

' For instance, we saw the `sum` function above which sums over an
  axes. We can apply `sum` to `x2` to produce the sum over 50 elements.

:t x2
:p sum x2

' Alternatively we can apply sum over `x3` to produce the sum over rows.

:t x3
:p sum x3

' How do we sum over the columns? In systems like NumPy you would
  do this by passing an axis argument to `sum`. Dex doesn't work this
  way. To sum over columns, you need to move columns to the front
  of the line. Luckily, you already know how to do this. 
  

:t x3

trans = for j. for i. x3.i.j

:t trans

:p sum trans

' The `sum` function seems to work independently of the index type of the
  array.

' Let's see how we can do this with our own functions. To define a function in
  Dex we use the following syntax (there are other ways to do it, but this
  one looks pretty close to Python.) 

def add5 (x:Int32) : Int32 = x + 5

:p add5 1

:t for i. add5 x2.i


' We can also write functions with type variables over their inputs. For instance
  we if we want to be able to `Add5` to any array. This function binds the type
  variable `n` to the index type of the array.  


def arrAdd5 (x : n => Int32) : n => Int32 = for i. x.i + 5
    
:t arrAdd5 x2


' But the function types can help you out even more.
  For instance, because index types are sized, you
  can use type inference to ensure the arguments passed in
  are valid.

' For instance, let's say we want to add two array together.

:t x
:t y


def arrAdd (x : m => n => Int32) (y : m => n => Int32) : m => n => Int32 =
    for i. for j. x.i.j + y.i.j

:t arrAdd x y

:t arrAdd x (trans y)

' Here the system type checked for us that they are the same size.


'## Writing Loops

' Dex is a functional language, but when writing mathematical algorithm
  it is often convenient to ignore that fact and write imperative code.

' For example, lets say we now want to actually write the `sum` function
  ourselves by accumulating summed values. In Python, We can't do this directly
  with list comprehensions, so we would write a loop.
  
'  `acc = 0`

'  `for i in range(10):`

'      `acc = acc + x[i]` 

' Variables are immutable in Dex, so we cannot do this directly. But we can
  write very similar code using the `state` effect. Here's what it looks like
  with the corresponding Python code.
  

def arrSum (x : a => Int32) : Int32 =
    -- acc = 0
    initAcc = 0

    -- (ignore for now)
    snd $ withState initAcc $ \acc.

         -- for i in range
         for i.
             -- acc = acc + x[i]
             acc := (get acc) + x.i
  
:p arrSum x2


' So even though we are functional, the loop looks quite
  similar to the imperative style. However there is one
  line which is quite new and a bit scary. Let us look
  into that line in a bit more detail.

' First `$`. This symbol is used in Dex the same way it is
  used in Haskell, but if you have haven't seen it before it
  is a bit strange. It basically takes the place of parens `( )`
  when you are too lazy to write them. For example, these two are the same:

:t arrSum (x2 + x2)

:t arrSum $ x2 + x2

' Next `\`. This symbol is the lambda operator in Dex. It makes a function
  that you can use right away, and behaves like `lambda` in python.
  Here the function takes an argument `acc` and returns the expression below (a `for` constructor).

' Finally, the function `snd` is from the prelude. It returns the second  of a pair, nothing fancy.

:p fst (1, 2)
:p snd (1, 2)


' That leaves `withState`. This function allows you to introduce imperative variables into the computation.
  It takes a intial values `initAcc` and a function of a reference to that value `\acc.` It then returns
  a pair of the result of that function and the final value. Here's a simple example

:p withState 10 $ \ state.
     state := 30
     20

' The first element in the pair is the function return (`20`) and the second is the final value of the variable (`30`).

' Finally this is a good point to talk a bit about some of the other operators in Dex.
  Here we see two types of equal signs `=` and `:=`. The first is the `let` operator that makes an
  immutable assignment. This one is built into the language and can be used anywhere you want. 


q = for i:(Fin 10).
        -- Bind a temp variable for some reason
        temp = (ordinal i) + 10
        for j:(Fin 5). temp
         
' The other is `:=` which can only be used inside of a `withState` block. It assigns
  a value to a mutable reference. To read that value you need to use the `get` function.
  or wait until the `withState` returns.


'## Type Classes

' Our arrSum function is pretty neat. It lets us work with any type index
  to compute the sum. However, it annoyingly only works for integers.

:t arrSum

' If we apply it to floats we get the following error.

arrSum for i : (Fin 5). 10.0

' We can compare the type of our sum to the built-in Dex `sum`.

:t sum

' It has another type variable `v` for the output. It also has the extra annotation
  `(Add v) ?=>`. This is a constraint that tells us that `v` can be any type in the
  `Add` type class.

' If we wanted to, we could look in the Dex prelude to see what this looks like. But we can
  probably guess what it means. `v` needs to be something where `add` works on it.
  We can do that! Let's define our own type class.

interface MyAdd a:Type where
  myAdd : a -> a -> a
  myZero : a

' This tells us that to be in the `MyAdd` type class, a type `a` needs to have
  a function `myAdd` and `myZero`. A type can then join the class like this.  


instance int32MyAdd : MyAdd Int32 where
  myAdd = \x y. x + y
  myZero = 0

instance float32MyAdd : MyAdd Float32 where
  myAdd = \x y. (x + y) 
  myZero = 0.0

' Once we have these two definitions, we can revisit our sum function. Here is how we modify
  the type.

def arrSum2 (_:MyAdd v) ?=> (x : a => v) : v =
    snd $ withState myZero $ \acc.
        for i.
            acc := myAdd (get acc) x.i

arrSum2 for i : (Fin 5). 10
arrSum2 for i : (Fin 5). 10.0

arrSum2 $ for i : (Fin 5).
           for j : (Fin 10). 10.0

' So it works for ints and it works for floats. But it failed when we tried to
  pass in a 2D array. What went wrong? The error tells us that it can't produce
  a class dictionary for `MyAdd ((Fin 10) => Float32)`. This makes sense as
  we have have not written one. We need to tell the system how to add columns.

' If we want, we can take the type checker literally and make this instance :).


instance specMyAdd : MyAdd ((Fin 10) => Float32) where
  myAdd = \x y. for i: (Fin 10). (x.i + y.i) 
  myZero = for i: (Fin 10). 0.0

arrSum2 $ for i : (Fin 5).
           for j : (Fin 10). 10.0


' Or we can treat it a more generally and extend to all 1D arrays.

instance arrMyAdd : (MyAdd v) ?=> MyAdd (a => v) where
  myAdd = \x y. for i. (myAdd x.i y.i) 
  myZero = for i. myZero

arrSum2 $ for i : (Fin 5).
           for j : (Fin 9). 10.0


' This now works for 3D arrays too. 

arrSum2 $ for i : (Fin 5).
           for j : (Fin 9).
             for k : (Fin 9). 10.0
  

' ## Prelude Practice


' There are a bunch of goodies implemented in the prelude
  that are worth knowing. It's good practice just to
  infer what these functions do from their type.
  
'  Here are a couple that come up a lot.


' * `select` for filtering

:t select 

select True 1 2
select False 1 2

' * `zero` for creating empty arrays

:t zero

myzero1 : (Fin 20 & Fin 10) => Float32 = zero
myzero2 : (Fin 20) => (Fin 10) => Float32 = zero

' * `zip` for creating tables of pairs

:t zip

:t zip x x
:t for i. zip x.i x.i


' * `iota` for create aranges 

:t iota

:p (iota (Fin 10))
:p for i. for j. (iota (Fin 4 & Fin 4)).(i, j)


' * Random numbers

:t newKey
:t splitKey
:t randn

key = newKey 0
(key1, key2, key3) = splitKey3 key

:p randn key1

' * `randVec` creates a random vector


randv = randVec 20 randn key2 
:t randv

randv2 = randVec 20 randInt key3
:t randv2


'## Worked Examples: Project Euler

' To demonstrate Dex in practice, here are some example
  functions solving problems on https://projecteuler.net/

  
def ignore (y:a) (x : Maybe a) : a =
  case x of
    Just x -> x
    Nothing -> y
    
instance maybeAdd : (Add v) ?=> Add (Maybe v) where
  add = \x y. Just $ ignore zero x + ignore zero y
  sub = \x y. Just $ ignore zero x - ignore zero y
  zero = Just zero


' ### Problem 1: Find the sum of all the multiples of 3 or 5 below 1000.



prob1 = for i : (Fin 1000).
          i' = ordinal i
          case ((i' `mod` 3) == 0 || (i' `mod` 5) == 0) of
            True ->  Just i'
            False -> Nothing
            
:p fromJust $ sum  prob1

' ### Problem 2: By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.


...


-- def maybeList (x : Maybe a) : List a =
--    case x of
--      Just a -> AsList 1 $ for i : (Fin 1). a
--      Nothing -> mempty

-- def remMaybe (x: n => Maybe a) : List a =
--      concat $ for i. maybeList x.i
