
:p m :: () -> {State Int} Int
   m () = get ()
   runState 2 m
> (2, 2)

:p m :: () -> {State Int} ()
   m () = put 3
   runState 0 m
> ((), 3)

:p m :: () -> {Reader Int} Int
   m () = ask ()
   runReader 5 m
> 5

:p
  stateAction :: () -> {State Real} ()
  stateAction () =
     x = get ()
     y = put (x + 2.0)
     z = get ()
     put (z * 3.0)
  --
  runState 1.0 stateAction
> ((), 9.0)

:p
  rwsAction :: () -> {Reader Int, Writer Real, State Bool} Int
  rwsAction () =
    x = get ()
    _ = tell 2.0
    _ = put (not x)
    r = ask ()
    _ = tell 4.0
    (r `iadd` 2)
  --
  runReader 2 $ lam (). runState True $ lam (). runWriter rwsAction
> ((4, 6.0), False)

:p m :: () -> {State (3=>Int)} ()
   m () =
     _ = puts (idxAsLens 0@3) 10
     _ = puts (idxAsLens 2@3) 20
     x = gets (idxAsLens 0@3)
     puts (idxAsLens 1@3) x
   runState [0,0,0] m
> ((), [10, 10, 20])

:p m :: () -> {Reader (3=>Int)} Int
   m () = asks (idxAsLens 1@3)
   runReader [1,2,3] m
> 2

:p
  m :: () -> {Writer Real, State Real} ()
  m () =
    x = get ()
    tell x
  runState 1.0 $ lam (). runWriter m
> (((), 1.0), 1.0)

myAction:: () -> {Reader Real, Writer Real} ()
myAction () =
  _ = tell 1.0
  _ = tell 2.0
  ()

:p runReader 1.0 $ lam (). runWriter myAction
> ((), 3.0)
