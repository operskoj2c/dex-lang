Int = %Int
Real = %Real
Type = %TyKind
Region = %Region
UnitTy = %UnitType

def IntRange (low:Int) (high:Int) : Type = %IntRange low high
def Fin (n:Int) : Type = IntRange 0 n
def Ref (r:Region) (a:Type) : Type = %Ref r a

def (+) (x:Real) (y:Real) : Real = %fadd x y
def iadd (x:Int) (y:Int) : Int = %iadd x y
def (**) (a:Type) (b:Type) : Type = %PairType a b
def (,) {a:Type} {b:Type} (x:a) (y:b) : a ** b = %pair x y
def fst {a:Type} {b:Type} (p:a**b) : a = %fst p
def snd {a:Type} {b:Type} (p:a**b) : b = %snd p

def get  {s:Type} {r:Region} (ref:Ref r s)       : {State r} s      = %get ref
def (:=) {s:Type} {r:Region} (ref:Ref r s) (x:s) : {State r} UnitTy = %put ref x

def withState
    {a:Type} {s:Type}
    (init:s)
    (action: {r:Region} -> Ref r s -> {State r} a)
    : (a ** s) =
    def explicitAction (reg:Region) (ref:Ref reg s) : {State reg} a = action ref
    %runState init explicitAction

:p iadd 3 (iadd 4 5)
> 12

def depId (a:Type) (x:a) : a = x

:p depId Int 1
> 1

def returnFirstArg (a:Type) (b:Type) (x:a) (y:b) : a = x

:p returnFirstArg Int Real 1 2.0
> 1

:p 1.0 + 2.0
> 3.0

def triple (x:Real) : Real = x + x + x

:p triple 1.0
> 3.0

def idExplicit (a:Type) (x:a) : a = x

:p idExplicit Int 1
> 1

def idImplicit {a:Type} (x:a) : a = x
:p idImplicit 1
> 1

idImplicit2 : ({a:Type} -> a -> a) = \x. x
:p idImplicit2 1
> 1

:p
  idImplicit3 : ({a:Type} -> a -> a) = \x. x
  idImplicit3 1
> 1

:p (\x y. x + y) 1.0 2.0
> 3.0

:p 1.0 + 1
> Type error:
> Expected: Real
>   Actual: Int
>
> :p 1.0 + 1
>          ^

:p iadd 1 (1.0 + 2.0)
> Type error:
> Expected: Int
>   Actual: Real
>
> :p iadd 1 (1.0 + 2.0)
>            ^^^^^^^^^

:p 1.0 + (iadd 2 3)
> Type error:
> Expected: Real
>   Actual: Int
>
> :p 1.0 + (iadd 2 3)
>           ^^^^^^^^

:p x + x
> Error: variable not in scope: x

iadd = 1
> Error: variable already defined: iadd

def TyId (a:Type) : Type = a
:p
  x : TyId Int = 1
  x
> 1

:p
  def TyId2 (a:Type) : Type = a
  x : TyId2 Int = 1
  x
> 1

def tabId {n:Type} (x:n=>Int) : n=>Int = for i. x.i

-- bug: this doesn't work if we split it across top-level decls
:p
  xs = for (i: Fin 3) . 1
  tabId xs
> [1, 1, 1]

myPair = (1, 2.3)

:p fst myPair
> 1

:p
   snd $ withState 2 \s.
     x = get s
     s := iadd x 3
> 5

:p
   snd $ withState 1 \s.
     for (i: Fin 10).
       x = get s
       s := iadd x x
> 1024
