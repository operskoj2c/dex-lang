def listLength ((AsList n _):List a) : Int = n

-- TODO: we want this for any monoid but this implementation won't work.
def concat (lists:n=>(List a)) : List a =
  totalSize = sum for i. listLength lists.i
  AsList _ $ fst $ withState 0 \listIdx.
    fst $ withState 0 \eltIdx.
      for i:(Fin totalSize).
        while (\(). get eltIdx >= listLength (lists.((get listIdx)@_))) \().
          eltIdx := 0
          listIdx := get listIdx + 1
        (AsList _ xs) = lists.((get listIdx)@_)
        eltIdxVal = get eltIdx
        eltIdx := eltIdxVal + 1
        xs.(eltIdxVal@_)


Point : Type = (Float & Float)

data Geom =
  Dot
  Circle Float
  Rectangle Float Float  -- width, height
  Line Point

-- HTML color string. TODO: consider an RGB triple instead
Color : Type = String

-- TODO: we should add overloaded string literals so we don't need this
def str (n:Int) ?-> (s:(Fin n=>Char)) : String = AsList _ s

black : Color = str "black"
white : Color = str "white"
gray  : Color = str "gray"
red   : Color = str "red"
green : Color = str "green"
blue  : Color = str "blue"

Attributes : Type = { fill   : Maybe Color
                    & stroke : Maybe Color
                    & lw     : Int }
defaultAttributes : Attributes = { fill   = Nothing
                                 , stroke = Just black
                                 , lw = 1 }

-- TODO: consider sharing attributes among a set of objects for efficiency
data Diagram = MkDiagram (List (Attributes & Point & Geom))

instance monoidDiagram : Monoid Diagram where
  mempty = MkDiagram mempty
  mcombine = \(MkDiagram d1) (MkDiagram d2). MkDiagram $ d1 <> d2

def concatDiagrams (diagrams:n=>Diagram) : Diagram =
  MkDiagram $ concat for i.
    (MkDiagram d) = diagrams.i
    d

-- TODO: arbitrary affine transformations. Our current representation of
-- rectangles and circles means we can only do scale/flip/rotate90.
-- Should we use lenses/isomorphisms for these instead?
def applyTransformation
      (transformPoint: Point -> Point)
      (transformGeom:  Geom -> Geom)
      (d:Diagram) : Diagram =
  (MkDiagram (AsList _ objs)) = d
  (MkDiagram $ AsList _ for i.
    (attr, p, geom) = objs.i
    (attr, transformPoint p, transformGeom geom))

flipY : Diagram -> Diagram =
  applyTransformation (\(x,y). (x, -y)) \geom. case geom of
    Dot           -> Dot
    Circle r      -> Circle r
    Rectangle w h -> Rectangle w h
    Line (x, y)   -> Line (x, -y)

def scale (s:Float) : (Diagram -> Diagram) =
  applyTransformation ( \(x,y). (s * x, s * y) ) \geom. case geom of
    Dot           -> Dot
    Circle r      -> Circle (s * r)
    Rectangle w h -> Rectangle (s * w) (s * h)
    Line (x, y)   -> Line (s * x, s * y)

def moveXY ((offX, offY) : Point) : (Diagram -> Diagram) =
  applyTransformation (\(x,y). (x + offX, y + offY) ) id

def singletonDefault (geom:Geom) : Diagram =
  MkDiagram $ AsList _ [(defaultAttributes, (0.0, 0.0), geom)]

-- TODO: should really allow nullary functions with `def`
dot                            : Diagram = singletonDefault Dot
def circle (r:Float)           : Diagram = singletonDefault $ Circle r
def rect   (w:Float) (h:Float) : Diagram = singletonDefault $ Rectangle w h
def line   (p:Point)           : Diagram = singletonDefault $ Line p

def updateAttributes (d:Diagram) (update: Attributes -> Attributes) : Diagram =
  (MkDiagram (AsList _ objs)) = d
  MkDiagram $ AsList _ for i.
    (attr       , geoms) = objs.i
    (update attr, geoms)

def setFill   (c:Color) (d:Diagram) : Diagram = updateAttributes d $ setAt #fill   (Just c)
def setStroke (c:Color) (d:Diagram) : Diagram = updateAttributes d $ setAt #stroke (Just c)
def removeFill          (d:Diagram) : Diagram = updateAttributes d $ setAt #fill   Nothing
def removeStroke        (d:Diagram) : Diagram = updateAttributes d $ setAt #stroke Nothing
def setLW     (w:Int)   (d:Diagram) : Diagram = updateAttributes d $ setAt #lw     w

-- === serialization ===

def quote (s:String) : String = str "\"" <> s <> str "\""

def (<+>) (s1:String) (s2:String) : String = s1 <> str " " <> s2

def angleBrackets (s:String) : String = str "<" <> s <> str "/>"

def tagBrackets (tag:String) (s:String) : String =
  str "<" <> tag <> str ">" <> s <> str "</" <> tag <> str ">"

def tagBracketsAttr (tag:String) (attr:String) (s:String) : String =
  str "<" <> tag <+> attr <> str ">" <> s <> str "</" <> tag <> str ">"

def makeAttr (attr:String) (val:String) : String =
  attr <> str "=" <> quote val

def punctuate (punctuation:String) (xs:n=>String) : String = todo

def colorStr (c: Maybe Color) : String =
  case c of
    Nothing -> str "none"
    Just s  -> s

def attrString (attr:Attributes) : String =
  (  makeAttr (str "stroke")       (colorStr $ getAt #stroke attr)
  <> makeAttr (str "fill")         (colorStr $ getAt #fill   attr)
  <> makeAttr (str "stroke-width") (show $ getAt #lw attr))

def dotAttrString (attr:Attributes) : String =
  (  makeAttr (str "stroke")       (colorStr $ getAt #stroke attr)
  <> makeAttr (str "fill")         (colorStr $ getAt #stroke attr)
  <> makeAttr (str "stroke-width") (show $ getAt #lw attr))

def renderGeom (attr:Attributes) ((x,y):Point) (geom:Geom) : String =
  case geom of
    Dot ->
     tagBracketsAttr (str "g") (dotAttrString attr) $ angleBrackets $
       (str "circle" <+>
        str "cx=" <> quote (show x) <>
        str "cy=" <> quote (show y) <>
        str "r=\"1\"")
    Circle r ->
     tagBracketsAttr (str "g") (attrString attr) $ angleBrackets $
       (str "circle" <+>
        str "cx=" <> quote (show x) <>
        str "cy=" <> quote (show y) <>
        str "r="  <> quote (show r))
    Rectangle w h ->
     tagBracketsAttr (str "g") (attrString attr) $ angleBrackets $
       (str "rect" <+>
        str "width="  <> quote (show w) <>
        str "height=" <> quote (show h) <>
        str "x="      <> quote (show (x - (w/2.0))) <>
        str "y="      <> quote (show (y - (h/2.0))))

BoundingBox : Type = (Point & Point)

def renderSVG (d:Diagram) (bounds:BoundingBox) : String =
  ((xmin, ymin), (xmax, ymax)) = bounds
  imgWidth = 400.0
  scaleFactor = imgWidth / (xmax - xmin)
  imgHeight = (ymax - ymin) * scaleFactor
  (MkDiagram (AsList _ objs)) = d |> flipY |> scale scaleFactor
  viewBoxStr = makeAttr (str "viewBox") $
     (show (xmin * scaleFactor) <+> show (-(ymax * scaleFactor)) <+>
      show imgWidth <+> show imgHeight)
  svgAttrStr = (    makeAttr (str "width" ) (show imgWidth)
                <+> makeAttr (str "height") (show imgHeight)
                <+> viewBoxStr)
  tagBracketsAttr (str "svg") svgAttrStr $
    concat for i.
      (attr, pos, geom) = objs.i
      renderGeom attr pos geom

-- === derived convenience methods and combinators ===

moveX : Float -> Diagram -> Diagram = \x. moveXY (x, 0.0)
moveY : Float -> Diagram -> Diagram = \y. moveXY (0.0, y)

-- mydiagram : Diagram =
--   (  (circle 7.0 |> moveXY (20.0, 20.0) |> setFill blue |> setStroke red)
--   <> (circle 5.0 |> moveXY (40.0, 40.0))
--   <> (rect  10.0 20.0 |> moveXY (5.0, 10.0) |> setStroke red)
--   )

-- :html renderSVG mydiagram ((0.0, 0.0), (100.0, 50.0))

