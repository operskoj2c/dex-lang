
data IntReal =
  MkIntReal Int Real

:p
  case MkIntReal 1 2.3
    MkIntReal x y -> (x, y)
> (1, 2.3)

data MyPair a:Type b:Type =
   MkMyPair a b

z = MkMyPair 1 2.3

:p z
> (MkMyPair 1 2.3)

:t z
> (MyPair Int Real)

:p
  case z
    MkMyPair x y -> (x, y)
> (1, 2.3)

data Dual a:Type =
   MkDual a a

:p
  d = MkDual 1 2
  case d
    MkDual x y -> (x, y)
> (1, 2)

:p for i:(Fin 3). MkMyPair (ordinal i) (ordinal i + 1)
> [(MkMyPair 0 1), (MkMyPair 1 2), (MkMyPair 2 3)]


:p
  tabOfPairs = for i:(Fin 3). MkMyPair (ordinal i) (ordinal i + 1)
  for i.
   case tabOfPairs.i
     -- TODO: investigate shadowing bug if we call these a and b
     MkMyPair x y -> (x + y, y)
> [(1, 1), (3, 2), (5, 3)]

data MyEither a:Type b:Type =
  MyLeft  a
  MyRight b

x : MyEither Int Real = MyLeft 1

:p x
> (MyLeft 1)

:p
  case x
    MyLeft  val -> val
    MyRight val -> floor val
> 1

-- %passes imp
myTab = [MyLeft 1, MyRight 3.5, MyLeft 123, MyLeft 453]

:p myTab
> [(MyLeft 1), (MyRight 3.5), (MyLeft 123), (MyLeft 453)]

:p for i. case myTab.i
  MyLeft  val -> val
  MyRight val -> floor val
> [1, 3, 123, 453]
