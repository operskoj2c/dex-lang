fst :: A a b. (a, b) -> a
fst (x, y) = x

snd :: A a b. (a, b) -> b
snd (x, y) = y

iadd :: Int -> Int -> Int
iadd x y = %iadd (x, y)

isub :: Int -> Int -> Int
isub x y = %isub (x, y)

imul :: Int -> Int -> Int
imul x y = %imul (x, y)

fadd :: Real -> Real -> Real
fadd x y = %fadd (x, y)

fsub :: Real -> Real -> Real
fsub x y = %fsub (x, y)

fmul :: Real -> Real -> Real
fmul x y = %fmul (x, y)

fdiv :: Real -> Real -> Real
fdiv x y = %fdiv (x, y)

pow :: Int -> Int -> Int
pow x y = %pow (x, y)

exp :: Real -> Real
exp x = %exp x

log :: Real -> Real
log x = %log x

sqrt :: Real -> Real
sqrt x = %sqrt x

sin :: Real -> Real
sin x = %sin x

cos :: Real -> Real
cos x = %cos x

tan :: Real -> Real
tan x = %tan x

hash :: Int -> Int -> Int
hash x y = %hash (x, y)

iota :: A i. i=>Int
iota = %iota ()

range :: Int -> E i. ()
range n = %range n

real :: Int -> Real
real x = %inttoreal x

fold :: A i a. i=>(a->a) -> a -> a
fold fs x0 = %fold (for i. lam x. fs.i x, x0)

rand :: Int -> Real
rand x = %rand x

-- TODO: automatically hoist the xs.i
sum :: A i. i=>Real -> Real
sum xs = fold (for i. let x = xs.i in lam c. c + x) 0.0

isum :: A i. i=>Int -> Int
isum xs = fold (for i. let x = xs.i in lam c. iadd c x) 0

map :: A i a b. (a -> b) -> i=>a -> i=>b
map f xs = for i. f xs.i

-- single :: A i. i -> Real -> i=>Real
-- single i x = %single (i, x)

-- TODO: need a (probably builtin) vector space typeclass
-- deriv :: (VSpace a, VSpace b) => ...
deriv :: A a b. (a -> b) -> a -> (b, a -> b)
deriv f = %deriv lam x. f x

jvp :: A a b. (a -> b) -> a -> a -> b
jvp f x t = snd (deriv f x) t

transpose :: A a b. (a -> b) -> b -> a
transpose f = %transpose lam t. f t

vjp :: A a b. (a -> b) -> a -> (b, b -> a)
vjp f x = let (y, df) = deriv f x
          in (y, transpose df)

grad :: A a. (a -> Real) -> a -> a
grad f x = let (_, pullback) = vjp f x
           in pullback 1.0
