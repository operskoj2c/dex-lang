-- --- mandelbrot v1 ---
-- features needed
--   type variable unpacking
--   records
--   pattern matching in lambda
--   type annotations in 'for' index
--   real arithmetic

--   underscore in pattern matching
--   type aliases
--   type annotations on top-level functions
--   general index sets

type Complex = (Real, Real)

x / i = unpack range 100

astype :: i=>a -> i=>b -> i=>a
astype x y = x

for i::i:

cSq :: Complex -> Complex
cSq (x, y) = (x^2 +. y^2, 0 - 2 * x * y)

cAbs :: Complex -> Real
cAbs (x, y) = sqrt (x^2 +. y^2)

iter :: Complex -> (Complex, Int) -> (Complex, Int)
c (z, n) = (cSq z + c, n + (cAbs z > 2))

z0 :: Complex
z0 = (0.,0.)

escapeTime :: Complex -> Int
escapeTime c = fold (const (iter c)) (z0, 0) maxItersV

linspace :: Real -> Real -> Int ->
linspace low high n = let /i = range n;
                          delta = high - low / asReal (n-1)
                      in pack i (asIdxSet for i::i: low + i * delta)

/xs = linspace -1.0 1.0 100
/ys = linspace -1.0 1.0 100

escapeTimes = for i~xs j~ys : escapeTime (i,j)

:plotmat escapeTimes


-- --- mandelbrot v2 ---
-- features needed
--   records
--   real arithmetic


maxIters = unpack range 100

cSq (x, y) = (x^2 + y^2, 0 - 2 * x * y)
cAbs (x, y) = sqrt (x^2 + y^2)
iter c (z, n) = (cSq z + c, n + (cAbs z > 2))
z0 = (0.,0.)
escapeTime c = fold (const (iter c)) (z0, 0) maxItersV

xs = linspace -1.0 1.0 100
ys = linspace -1.0 1.0 100

escapeTimes = for i j : escapeTime (xs.i,ys.j)

:plotmat escapeTimes
