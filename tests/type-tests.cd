:t lam x. x

> A a. (a -> a)

:t lam x. sum for i. x.i

> A a. (a=>Real -> Real)

:t let flip f x y = f y x in flip

> A c b a. ((b -> (a -> c)) -> (a -> (b -> c)))

:t lam x. for i j. x.j.i

> A c b a. (b=>a=>c -> a=>b=>c)

:t lam f x. f x

> A b a. ((a -> b) -> (a -> b))

:t let id x = x
   in id (id) (id 1)

> Int

:t let _, n = unpack range 10;
       x = iota :: n=>Int
   in isum x

> Int

:t let _, nx = unpack range 10;
       _, ny = unpack range 3;
       x = iota :: nx=>Int;
       y = iota :: ny=>Int
   in real (isum for i. x.i) + real (isum for j. y.j)

> Real

:t let _, nx = unpack range 10;
       _, ny = unpack range 3;
       x = iota :: nx=>Int;
       y = iota :: ny=>Int
    in sum for i. x.i + y.i

> Type error: can't unify ny and nx

:t let _, nx = unpack range 10
   in iota :: nx=>Int

> Type error: existential variable leaked

_, arrN = unpack range 10

arr = iota :: arrN => Int

xr = map real arr


:t arr

> arrN=>Int

:t (lam (x, y). x + y) (1.0, 2.0)

> Real

:t let f (x, y) = x + 2.0 * y;
       z.i = (xr.i, xr.i * xr.i)
   in sum (for i. f z.i)

> Real

-- yields 'compiler bug'. Should be a different sort of error
-- :t unpack x = iota 3
--    in let y = for i j. x.i * x.i
--       in sum (for i. sum (y.i))
:t 1 :: Int

> Int

:t 1.0 :: Int

> Type error: can't unify Real and Int

