:t lam x. x

> A a. (a -> a)

:t lam x. sum for i. x.i

> A a. (a=>Real -> Real)

:t let flip f x y = f y x in flip

> A c b a. ((b -> (a -> c)) -> (a -> (b -> c)))

:t lam x. for i j. x.j.i

> A c b a. (b=>a=>c -> a=>b=>c)

:t lam f x. f x

> A b a. ((a -> b) -> (a -> b))

:t let id x = x
   in id (id) (id 1)

> Int

:t let x, n = unpack iota 10
   in isum x

> Int

:t let x, nx = unpack iota 10;
       y, ny = unpack iota 3
   in real (isum for i. x.i) + real (isum for j. y.j)

> Real

:t let x, nx = unpack iota 10;
       y, ny = unpack iota 3
   in sum for i. x.i + y.i

> Type error: can't unify ny and nx

:t let x, nx = unpack iota 10
   in x

> Type error: existential variable leaked

arr, arrN = unpack iota 10


xr = map real arr


:t arr

> arrN=>Int

:t (lam (x, y). x + y) (1.0, 2.0)

> Real

:t let f (x, y) = x + 2.0 * y;
       z.i = (xr.i, xr.i * xr.i)
   in sum (for i. f z.i)

> Real

-- yields 'compiler bug'. Should be a different sort of error
-- :t unpack x = iota 3
--    in let y = for i j. x.i * x.i
--       in sum (for i. sum (y.i))
:t 1 :: Int

> Int

:t 1.0 :: Int

> Type error: can't unify Real and Int

