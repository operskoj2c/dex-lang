:t lam x: x
A a. (a -> a)

:t lam x: sum for i: x.i
A a. (a=>Int -> Int)

:t let flip f x y = f y x in flip
A a b c. ((c -> (b -> a)) -> (b -> (c -> a)))

:t lam x: for i j: x.j.i
A a b c. (c=>b=>a -> b=>c=>a)

:t lam f x: f x
A a b. ((b -> a) -> (b -> a))

:t let id x = x
   in id (id) (id 1)
Int

:t let x = unpack iota 10
   in sum x
Int

:t let x = unpack iota 10;
       y = unpack iota 3
   in (sum for i: x.i) + (sum for j: y.j)
Int

:t let x = unpack iota 10;
       y = unpack iota 3
   in sum for i: x.i + y.i
Type error: existential variable leaked scope

:t let x = unpack iota 10
   in x
Type error: existential variable leaked scope

:t x
x=>Int

:t (lam (x, y): x + y) (1, 2)
Int

:t let f (x, y) = x + 2 * y;
       z.i = (x.i, x.i * x.i)
   in sum (for i: f z.i)
Int

